## Redis的高性能I/O模型

### 一、Redis是单线程

1. Redis的单线程，主要是指Redis的网络IO和键值对读写两部分操作是由一个线程来完成的，即Redis对外提供键值存储服务的主要流程；

2. 但是Redis的其他功能：持久化、异步删除、数据同步等都是额外线程执行；

### 二、为什么使用单线程

1. 多线程的优势：在==资源合理分配==的情况下，多线程可以增加系统中处理请求的实体，从而提升系统处理的吞吐量
2. 多线程的问题：在面临共享资源时，需要保证多线程并发访问控制的正确性；需要调用额外机制，从而带来额外的开销；

### 三、Redis单线程的设计

​	一是Redis都是内存操作；二是使用了==IO多路复用机制==；

### 四、 IO多路复用机制

1. 在socket网络通信模型下，有两个可能导致阻塞的节点，分别是调用`accept()`方法和调用`recv()`方法；
   * `accept()`方法：Redis节点或集群监听到有客户端的连接请求，但一直未能成功创建出连接则会阻塞；
   * `recv()`方法：Redis节点或集群建立和客户端连接后，一直等待客户端传输数据则会一直阻塞；
2. `Socket`模型可以设置非阻塞的套接字；
   * 由于调用会导致阻塞的`accept()`方法是`Listen()`方法创建的==监听套接字==；所以针对`Listen()`方法设置创建的==监听套接字==为非阻塞的，这样在一个请求过来创建连接时，调用`accept()`方法后，Redis不需要再等待方法执行完毕，会有非阻塞的机制在完成后通知Redis进程；
   * 同理，我们可以设置`accept()`方法创建的==已连接套接字==为非阻塞的，这样在调用`recv()`方法接收数据时，可以再有数据到达时再通知Redis。

3. 多路复用I/O模型实际的实现
   * 多路复用I/O的本质实际上是一个线程处理多个IO流，由Linux的`select/epoll`机制保障；
   * Linux操作系统内核可以允许同时存在多个连接套接字或者监听套接字（统称为`FD`），内核会监听这些套接字，在请求到达时通知Redis；
   * 该机制提供了**基于事件的回调机制**，当有请求达到时，会触发内核针对不同的事件，调用不同的处理函数；
   * 由于Redis是单线程，所以当多个事件发生时，会放入一个事件队列，内核根据队列中事件的类型，逐一调用Redis进程的函数对不同事件进行处理。
