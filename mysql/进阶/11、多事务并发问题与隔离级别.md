## 事务并发问题

> 四大问题：脏写、脏读、不可重复读、幻读

#### 脏写

- 事务A和B操作同一条数据，事务A先修改数据，事务B后修改数据，但之后事务A回滚，导致事务B的数据修改丢失
- 本质：不同事务操作同一个数据，事务B操作事务A修改过的值，但事务A还没提交，会随时回滚导致

### 脏读

- 事务A修改了数据M的值，在事务A还未提交时，事务B查询数据M；事务A此时回滚，导致事务B再次查询时，查询不到刚才的值；
- 本质：事务读取到了不同事务未提交时修改的数据值，而别的事务随时可以回滚导致；

> 脏读和脏写都是因为一个事务更新或读取别的事务正在修改的值，而别的事务随时可能回滚导致；
>
> 因为读到的都是脏页的信息（事务未提交），所以称为脏读、脏写。

#### 不可重复读

- 前提：事务中只能查到其他事务提交的数据（避免脏读）；
- 事务A读取一次数据M的值后，事务B修改了数据M的值，事务A再次读取时，数据M的值和第一次读取的不同，同一事务中读取到的相同数据的数值不同；
- 本质：事务执行过程中，别的事务提交修改导致本事务执行过程中重复查询的值都不一样。

#### 幻读

- 事务A查询表S的数据，获取到10条数据；此时事务B增加了两条数据，事务A再次查询表S的数据时，获取到12条数据；同一条SQL，前后读取会有额外增加数据量；
- 特指：不同时间段，使用相同的语句查询到之前没见过的数据。



## SQL事务隔离标准

> 读未提交、读已提交、可重复读、串行化

#### 读未提交 `read uncommitted`

- 不允许脏写，但是允许发生脏读、不可重复读、幻读；
- 即只限制当前事务不能对别的事务中未提交的数据更新，再进行修改；

#### 读已提交 `read committed`

- 简称：`RC`;
- 不允许脏写、脏读，但允许发生不可重复读、幻读。

#### 可重复读 `REPEATABLE READ`

- 简称：`RR`;
- 不允许脏写、脏读和不可重复读，但允许发生幻读。

#### 串行化 `serializable`

- 事务串行处理；根本不会有并发问题；

## MySQL中隔离机制

- 也是同样以上四种标准，但是MySQL默认设置的事务隔离级别是：**`RR`**，**可以避免幻读**！即事务之间完全不受影响
- 依托于**MVCC机制**。
- 修改MySQL事务隔离级别可使用以下指令：

```
SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;
```

- 上面指令中`LEVEL`的值可以是：`REPEATABLE READ`，`READ COMMITTED`，`READ UNCOMMITTED`，`SERIALIZABLE`几种级别；