1. 腐烂的橘子
在正方格中，一个腐烂橘子每分钟会感染整上下左右相邻的橘子，求感染所有格子中橘子的最小分钟数。
    方法一：枚举+广度优先搜索
    **为什么会想到广度优先，因为有所有相邻会被感染（改变）**，即下一刻修改该节点所有相邻子节点。然后由于腐烂橘子不止一个，所以需要求出所有腐烂橘子感染每个节点的时间进行比较（一个腐烂橘子序列）。dis[x][y][j]表示坐标为（x，y）的节点被第j个腐烂橘子感染的时间。答案是，**在每个节点都是最小感染时间下**，得出最大值。
    方法二：多元广度优先搜索
    **所有烂橘子都可以等价于同一层的节点**，假设在-1分时有一个烂橘子，在0分时感染所有已知的烂橘子，就可以使用**队列**将所有烂橘子放进去，分别进行广度优先搜索就行了。
    实际代码实现中：将坐标（x,y）的节点转换成一个整数node，x*列数+y = node；使用Queue队列（使用ArrayDeque实现类）和map（用来记录每个node的感染时间），还需要一个整数N来记录当前时间。
    **技巧：**
    1. 对于方格节点n(x,y)方位变化的处理：使用两个数组d1 = {-1,0,1,0}和d2{0,-1,0,1}来方便表示n上下左右格的节点；如：(x+d1[0],y+d2[0]);
    2.如果需要额外记录方格或坐标节点（x,y），可以考虑使用转换成一个整数code的方式。 


2. 零钱兑换
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
注意：硬币只是给了面值，数量没有规定。
    方法一：回溯法，但是会超时；
    方法二：动态规划：设总金额n，最少硬币数为f(n);则f(n) = minf(n-ci)+1,ci是不同面额的硬币。


3. 买卖股票 第121道
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。
注意你不能在买入股票前卖出股票。
    方法一：直接两次循环遍历数组，然后算出差值最大的。
    方法二：一次遍历数组，只计算上升序列的差值。使用一个变量Minpricr来记录当前遇到最低的价格，另一个变量min来记录最大差值（仅在minprice之后，遇到更大值时计算差值。）

4. 矩阵顺时针输出
    思路：设置四条边界：l,r,b,t左右下上，然后通过边界来结束输出。

5. 从一个数组中找最小的K个数 TOPK问题
    思路：
    >1. 先排序后取前K个数；
    >2. 使用堆的特性来获取；**由于是最小的K个数，所以使用大顶堆**；首先将**前K个数插入到大顶堆**中，如果遍历到比大顶堆的堆顶的数要小，则把堆顶弹出，插入遍历到的数，最后取出大顶堆中的数即可。
    >3. 使用快排的思想；利用快排返回中间值排序后所在的下标，根据下标来判定这一次排序左边是否满足K个最小值；
 