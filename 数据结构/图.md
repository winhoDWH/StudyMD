1. 定义：
    表示多对多关系；
    使用**顶点集V和边集E**来表示;**(a,b)表示无向边，<a,b>表示有向边**；不考虑自回路（自己指向自己）；
2. 邻接矩阵
    * G[N][N]一个N*N的矩阵;G[a][b]=1代表有a到b的边，G[a][b]=0代表没有边。
    * 对角线上的元素都为0（没有自己指向自己的边）；
    * 无向边时，矩阵是对角对称的；
    * 如果有权重，则把权重作为矩阵的值；
    * 如何剩一半的空间？
        >使用一个一维数组存储一半的矩阵（下三角）；数组长度为N(N+1)/2,则原矩阵Gij对应的下标是：i*(i+1)/2 + j ;(**仅仅适用于i>j的情况，因为存的是下三角的值**)；
    * 矩阵表示的好处：1.方便检查顶点之间是否存在边；2. 方便找邻接点；3.方便计算度； 
    * 缺点：对稀疏图，浪费空间和时间；
3. 邻接表
    * 数组加链表的结构：G[N]表示第几个顶点，存放一个链表，表示其边；
    * 每个节点：**会有一个指针指向下一个节点，一个数存连接的节点编号，一个数存权重；**
    * 图够稀疏才有效；
    * 优点：
        >1. 方便找邻接点；
        >2. 节约稀疏图的空间（多稀疏才节约？）
        >3. 方便计算**无向图的度**，但不方便计算有向图的；
    * 缺点：不能检查任意节点间是否有边；
4. 深度优先遍历DFS：
    * 不到南墙不死心：不断访问一个节点的子节点直到没有子节点，然后返回上一层节点，再访问其他的子节点；
    * 时间复杂度，N个顶点，E条边：
    >1. 使用**邻接表**来存储：O(N+2E);因为是**链表储存，每个顶点的链表就代表了一串边，每访问一个顶点就都要访问其所在边，由于无向图总的是两条边，所以是2E**
    >2. 使用**邻接矩阵**：O(N平方)；
5. 广度优先遍历
    * 思想：先把所有子节点访问完，再进入下一层进行访问；
    * 实现思路：先把一个点压入队列，然后再把所有直接相连的点压入队列中，再从队列中取一个元素，再将其子节点压入队列，以此类推。