1. 冒泡排序
冒泡排序就是**把小的元素往前调**或者把大的元素往后调。相邻的两个元素比较与交换
特点：稳定，时间复杂度为比较((n-1)+(n-2)+...+3+2+1)=n*(n-1)/2次，即**O(n^2)**;
实现：两层循环，最外层遍历整个数组，提供第i大(或小)的位置；第二层循环对i剩下的数组进行两两对比，循环方向与第一层循环相反。如：第一层循环从数组末开始，表示第i大数据的位置，第二层循环从头开始直到i的位置，两两对比交换相邻数据谁大。
本质:通过for循环 利用两两比较的方式依次找到**相对大值放在右边**,实现每次循环后,将未排序的数组部分最大值放在右边

2. 选择排序
本质:每次循环,找到该次循环的最小值,记录该循环最小值的索引，然后交换完成排序。

3. 插入排序
基本思路：把数组序列分为有序和无序两部分，从无序部分抽出一个数据插入到有序队列中。
实现思路：外层循环访问无序部分第i个元素（**即从数组的第二个元素开始**），以这个i元素为指标，对比有序数组，插入到有序数组的相应位置，有序数组往后移一个。

优化：二分插入排序
在插入元素的过程中，放弃之前逐个对比的方法，在有序序列中使用二分查找，找到插入的位置后再进行数据后移。其中，二分查找记住：如果相等则保证插入点在旧元素之后。
时间复杂度：最好O(nlogn),最坏是：O(n^2);平均是O(n^2)；

4. 快速排序
首先在数组中选择一个基准点（该基准点的选取可能影响快速排序的效率，后面讲解选取的方法），然后分别从数组的两端扫描数组，设两个指示标志（lo指向起始位置，hi指向末尾)，首先从后半部分开始，如果发现有元素比该基准点的值小，就交换lo和hi位置的值，然后从前半部分开始扫秒，发现有元素大于基准点的值，就交换lo和hi位置的值，如此往复循环，直到lo>=hi,然后把基准点的值放到hi这个位置。一次排序就完成了。
```
while(i<=j){
    while(privot<a[i]){ //privot为基准值
        i++;
    }
    while(privot>a[j]){
        j--;
    }
    if(i<=j){
        交换i和j的数据。
    }
}
```
>时间复杂度分析：
>* 快排的时间复杂度取决于**划分区间是否平衡**
>* 最好情况：但区间为等分的情况下(即**选取的基准值正好为序列中值**)，则**划分logn次，每次划分都需要访问n个元素（访问所有元素）**，所以复杂度为O(nlogn)；
>* 最坏情况：**每次选的基准值为序列最大值或者最小值**，则**每次划分，有一个区间只有一个元素，需要划分n次，每次遍历n-i个元素**，所以时间复杂度为O(n平方)；
>* **当我们选取序列第一个元素或最后一个元素为基准值时，已经有序的序列为最坏情况**；但如果我们选取的是序列中间数（**不是中间值**）时，则最坏情况为每次都选取区间最大或最小的值。

5. 归并排序
    将已有序的子序列合并，得到完全有序的序列；不断把待排序列中间二分，直到不能再分；此时二分的序列（只有一个元素）肯定是有序的，再逐一进行归并操作。
    优化
    >* 第一步优化：在待二分的序列元素少的时候使用插入排序；
    >* 进一步优化：在归并前进行判断：由于**待归并的序列一定是有序的，所以取左序列的最大值（最后一个元素）A和右序列最小值（第一个元素）B进行对比，如果B>=A则不用进行归并；**
    >* 再进一步优化：只开辟一次空间。


6. 堆排序
大顶堆：父节点总比其左右子节点要大；
小顶堆：父节点总比其左右子节点要小；
堆是完全二叉树，其左子节点是父节点的编号两倍+1，右节点是编号两倍+2；实际用数组存储。
思路：先对堆数据进行交换，使其成为一个大顶堆（数据并不有序），其数据最大值在堆顶（即数组第一个元素），这个过程称为**一次建堆**，然后与最后一个元素交换。反复重复该过程即可。
**本质上：通过堆的特性，每次建堆把数组中最大值选出来，然后排到数组最后。**

7. 希尔排序
插入排序优化版，使用增量序列，把一个待排序列分成相应增量的子序列。如6个元素的序列，增量序列为{3,1}，第一次把序列分成3个子序列，子序列分别进行插入排序；第二次把原序列（6个元素）分成1个子序列（即自身），进行插入排序。

8. 桶排序
对于一组N个数据，有一个取值空间[0,K],则可以使用k个桶来存放每一个数据，采用链式方式解决冲突问题；然后再按桶的顺序取出，则数组序列成有序。**时间复杂度为：O(K+N),遍历一次数组则为N次，再从桶中取数据K次**；

9. 基数排序（特殊的桶排序）
    * 解决问题：当桶排序的数组**K远大于N时，即会有很多空桶**则使用基数排序；
    * 思路：基数排序使用R个桶（基数），**一般R=10（后面统一使用10来作为标准）**；由于R=10，然后对数组中每个数先根据个位进行比较，并放入对应桶中（求余），遍历完全后**按桶顺序依次将数据重新收集，再对新的数组进行十位、百位等比较**，最后数组最高位比较完后，数组就有序了；
    * 时间复杂度为：O(d(R+N)),d为数组最高位数；
    * **在实现中，无法比较带有负数和0的数组，并且空间占用高，因为要开辟一个K*a.length大小的桶空间**。
    * 应用
    >多关键字排序：值有多个比较的指标，比如扑克牌有花色和数值两种指标，则分为主位优先和次位优先两种方式；主位优先：先对花色进行建桶，再对数值建桶；次位优先：先对数值进行建桶，后对花色进行建桶。