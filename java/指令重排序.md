并发线程的三个问题：
1. 原子性
    即一个操作或多个操作要么全执行并其执行过程中不会被任何因素打断，要么不执行。
    在java中对**基本数据类型的变量的读取和赋值操作是原子性操作，且必须是将数字赋给某个变量才是，变量之间赋值不是。**
2. 可见性
    当多个线程访问同一个共享变量时，一个线程修改了该变量的值，其他线程能立即看到修改后的值。
3. 有序性
    程序执行顺序按照代码顺序执行；（由于指令重排会导致不一致。）

一、指令重排序
表现：代码指令和代码执行语句顺序不同；
意义：提高性能。
 **指令重排不会影响单线程，但会影响多线程。**
类型：
1. 编译器优化的重排序
> 编译器会在不改变程序语义前提（？）下，重新安排语句的执行顺序

2. 指令级并行的重排序
>现处理器使用了指令级并行技术，重新安排语句执行顺序。如果不存在数据依赖性，则处理器可以改变语句对应的执行顺序。

3. 内存系统的重排序
由于处理器会使用缓存和读/写缓冲区，所以执行结果不会第一时间存在内存中，所以使得加载和存储像乱序；现在单个处理器都会有一个内存缓冲区，**在多核CPU中每个线程可能运行于不同的CPU**，而线程之间有共同变量时，不能保证数据可见性。（**缓存一致性问题**）

4. 从java源代码到最终实际执行的指令序列，会按顺序依次经历以上三种重排。

5. **1属于编译器重排序，2和3属于处理器重排序。**

小知识点：JMM是java内存模型(java memory model)即JVM计算机内存中的工作方式；用来屏蔽各大硬件平台和操作系统的内存访问差异，实现java程序在多平台下都能达到一致的内存访问效果。定义了程序中变量的访问规则与程序的执行次序。规定了**每个线程都必须在自己的工作内存中执行，不能直接对主存进行操作，且每个线程不能访问其他线程的工作内存。**

6. 对于编译器，JVM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JVM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。 JVM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。


内存屏障指令
1. 疑问：四个名词的区别：装载，刷新到内存，存储指令，内存访问指令。
内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为下列四类：
..........

数据依赖：
1. 如果两个操作访问同一个变量，且其中一个为写操作，则两个操作存在数据依赖。
2. 分为三种类型：写后读，写后写，读后写。

as-if-serial语义：不论如何重排，前提是不能改变（**仅限在单线程中**）程序的执行结果。
happens-before 原则(先行发生原则)保证了有序性
```
(1)、程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；

(2)、锁定规则：一个 unLock 操作先行发生于后面对同一个锁额 lock 操作；

(3)、volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；

(4)、传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C ；//传递性

(5)、线程启动规则：Thread 对象的 start() 方法先行发生于此线程的每个一个动作；

(6)、线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生；

(7)、线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；

(8)、对象终结规则：一个对象的初始化完成先行发生于他的 finalize() 方法的开始。
```
**注意，第一条规则中是对单一线程而言，所以实际上处理器只要不对有数据依赖的指令进行重排，宏观上就是符合代码顺序执行的，即实际上还是可能会有重排**

控制依赖
    当代码中有if判断时，会产生控制依赖；有控制依赖后，会影响并行度，所以编译器和处理器会采用猜测来克服相关性并行度的影响，会进行指令的重排序；如把if判断后的赋值语句在判断之前执行读取指令，导致在多线程有并发问题。


原文链接：https://blog.csdn.net/yjp198713/article/details/78839698
参考：https://blog.csdn.net/zxd1435513775/article/details/84787471
   
volatile关键字
>    （1）保证了不同线程对共享变量操作时的可见性。
>    （2）禁止进行指令重排序。（有序性）
volatile会执行缓存一致性协议，著名的为MESI协议：当有一个CPU**写入数据**时，如果发现该变量为共享变量（即其他CPU缓存中也有该变量的副本），则会通知其他CPU，将其内变量缓存状态设置为无效；因此别的CPU就必须重新在主内存中读取该变量了。
1. 保证了可见性但是**不保证原子性**
    >原因：首先要分清**禁止指令重排序与原子性**，volatile禁止重排序是指：在**在单线程中**对volatile修饰的变量进行操作时，其操作指令不会有重排序；如：
    ```
    volatile Singleton Single;
    Single = new Singleton();//单例模式
    ```
   >在创建对象这个**操作**中，**会分为三个指令:**
   ```
    1.memory =allocate(); //分配对象的内存空间
    2.ctorInstance(memory); //初始化对象
    3.Single =memory; //设置instance指向刚分配的内存地址
   ```
   >**由于2和3之间没有数据依赖，所以如果没有禁止重排序，2和3会互换**；所以单例模式中为什么需要使用volatile来修饰单例对象，原因在于如果重排序了，**Single对象分配了内存空间（指令3）但是没有初始化（指令2），则会有些线程会出现single!=null这个条件成立，会返回一个没有初始化的单例对象。**
   >但是这种禁止重排序**不代表该操作为原子操作了**，因为在多线程仅仅只是保证了**该单一线程的指令之间相对顺序不变**，指令之间可能插入很多别的线程的指令。 
2. 使用要满足一下条件：(1)、对变量的写操作不依赖于当前值；(2)、该变量没有包含在具有其他变量的不变式中。所以其主要的使用场所为：**在多线程环境下及时感知共享变量的修改，并使得其他线程可以立即得到变量的最新值。**如：修饰用于状态标记的变量或者是用于验证检查的变量（单例模式）。

synchronized修饰符
**保证了原子性，而且保证同一时间只有一个线程执行某段代码，但这段代码不能保证不会重排序（即没有volatile的有序性）**，**但是在运行同步块代码时会让该线程的工作内存与主内存同步**。
**System.out.println()方法有同步代码块**，所以调用该方法会让其线程强制同步主内存。（https://blog.csdn.net/zxd1435513775/article/details/84787471的示例中的几个可见性情况。）