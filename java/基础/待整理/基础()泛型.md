## 泛型
### 使用在类、接口中
1. 把类参数化称为泛型,在调用的时候动态地指定传入实际的类型；在集合、接口和类后使用尖括号，并声明一个类名，即可使用泛型，如：List<String>;
2. 使用泛型定义了一个对象后，创建对象时，必须在构造器后加尖括号，如：List<String> list =new ArrayList<>();
3. 在定义类和接口时，声明类型形参：
    ```
    interface Test<E>{
        E test();
    }
    ```
4. **注意**：当有泛型定义的类和接口被实现时，不能为该父类和接口再加入泛型定义，如：
    ```
    //错误的
    public class A extends Apple<T>{}
    ```
    因为**有泛型定义的类或接口在被调用的时候必须指定泛型类型！**，所以有两种方式：
    * 1. 显示指出泛型类型；这种情况需要注意，**重写父类方法时，涉及到泛型类型的，都必须统一写成相应类型！**
    ```
    public class A extends Apple<String>{}
    ```
    * 2. 不显示指出泛型类型；这种情况，**编译器会发出警告，且默认将父类方法中的的泛型类型当成object类型**
    ```
    public class A extends Apple{}
    ```
    * 3. 在java的集合的源码中，很多集合类的泛型继承都是使用第一种方式，即显示声明了父类的泛型类型，但同时子类也声明了泛型，从而保证了子类也是有泛型；如：
    ```
    //继承了Collection，但是自己也声明了泛型E；
    //并用这个E作为父类泛型类型
    public interface List<E> extends Collection<E>
    ```
5. 由于**泛型是动态定义的，所以编译时，定义了泛型的类都是一样的**。所以类的**静态方法、静态初始化块、静态变量**这三种的声明和初始化不能使用泛型，因为这三种对于所有类对象都一样。
6. instanceof运算符后不能使用泛型
```
List<String> L = new ArrayList<>();
//下面这段代码是错误的
L instanceof Collection<String>;
```
7. 注意：**类似List<String>不是List<Object>的子类**，即不能根据泛型类型的子父类关系确定类的子父类关系！
8. 泛型的设计原则：**只要编译不发生警告，则运行时不会出现ClassCastException异常（类不符合的异常）**；

### 泛型通配符
1. 由于**调用定义了泛型的类时，必须要显式声明泛型类型，不然会默认为Object类型**，所以如果希望能匹配所有泛型类型的话，则要使用通配符“?”；
    ```
    public void test(List<?> t){}
    //不显式声明
    //public void test(List t){}------(1)
    ```
2. 如果不声明类型的话，即(1)代码，则参数t会默认为 List<Object> 类型，如果想传入List<String>类型的实参时，会报类型不匹配的错（List<String>不是List<Object>的子类）；
3. 一种限制的通配符，如：List<? extends 类名>，指限制这个泛型必须是某个类的子类。
4. 使用通配符时，不能往使用类通配符声明的集合中放入元素，因为**程序不确定集合内元素是什么**，即**java不允许将对象放入到一个未知类型的集合中**，如：
    ```
    //使用通配符定义的
    public void test(List<?> t){    //或者List<? extends Object> t
        //会发生编译错误！
        t.add(new Object);
    }

    //使用正常泛型定义的
    public <T> void test(List<T> t){    //下面的泛型方法
        //不会报错！因为类型确定
        t.add(new T());
    }
    ```

**总结一下针对泛型定义的特殊情况，就是调用有泛型定义的类时，必须显式声明泛型类型！**


##泛型用在方法中
1. 定义的方式
```
修饰符 <T,S> 返回类型 方法名（参数列表）{
    //方法体
}
```
2. <>尖括号中是负责声明**类型形参**，代表未确定的类型，可在方法中使用这些类型形参；如：
```
 static <T> T test(T[] t,int a){
     for(T o : t ){
         ....
     }
 }
```
3. 泛型用在方法中时无需显示声明传入的泛型类型，编译器会自动根据实参的类型来判断，所以不能让系统迷惑，如：
```
 //泛型方法
 static <T> T test(T[] t,T a){}
 //调用泛型方法时传入一个字符数组和一个整型
 //会报错
 test(new String[8],new Integer(8));
```

泛型方法和泛型通配符(?)都是用于解决泛型在方法中的应用，可以进行相互转换的，一般用泛型方法来表示参数列表中，参数A和参数B之间存在的依赖关系；
```
public class Test<E>{
    //泛型方法
    <T>boolean containsAll(Collection<T> c);
    <T,S extends T>void test(List<T> a,List<S> b);//参数a和b有依赖关系

    //通配符
    boolean containsAll(Collection<?> c);
    void test(List<?> a,List<? extends E> b);
    //由于通配符不能体现出a和b有依赖关系，所以就使用<? extends E>来说明一下类的泛型和方法中泛型之间的联系
}

```

##通配符的上下限：
上限：<? extends E>;表示必须是E的子类；
下限：<? super E>;表示必须是E的父类或者E本身；
注意：一个类中不能同时存在有上限定义和有下限定义的相同方法名的两个方法（方法重载），如：
```
class Test{
    //上限
    <T> void Copy(List<T> dest , List<? extends T> src){.....};
    //下限
    <T> T Copy(List<? super T> dest , List<T> src){......};
    //别的类调用Copy方法时，编译器无法判断使用的是哪个方法，会报错
}
```

##泛型的擦除和转换
1. 擦除：指将一个定义了泛型类型的类对象A，赋值给没有定义泛型类型的类变量B，导致B丢失了A的泛型类型，并使用其类型参数的上限(默认是Object)；如：
```
//该类的泛型上限是Number
class Apple<T extends Number>{
    T size;
    Apple(T t){
        size = t;
    }
    T getsize(){
        return size;
    }
} 

class Test{
    void main(){
        //定义了泛型类型,并赋值size
        Apple<Integer> a = new Apple<>(1);
        //赋值给没有定义的
        Apple b = a;
        Integer s1 = a.getsize();//不报错
        Integer s2 = b.getsize();//编译报错，因为此时size类型为Number
    }
}
```
2. 转换：与擦除相反，将一个声明了泛型类型的对象赋值给一个没有声明泛型类型的对象；
```
Apple a = new Apple();
Apple<String> b = a;
```
进行转换时，编译会报“未经检查的转换”的警告，运行时会发生异常；

##泛型与数组
1. 只能声明元素为泛型类型的数组，不能创建其对象，如：
```
//声明时可以的
List<String>[] list;
//以下的创建是不被允许的
list = new ArrayList<String>[10];
```
2. 允许创建**无上限的通配符泛型数组**，如：
```
List<?>[] list = new ArrayList<?>[10];
```
但是要注意强制类型转换的问题；
3. 创建类型变量会报错，如：new T[SIZE];T是泛型。