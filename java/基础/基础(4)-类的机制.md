## 类的相关机制
### 继承：extends
继承中的构造方法：
* 子类的构造方法必须调用父类的构造方法，所以如果父类没有**无参数构造方法，那么子类对象必须显示调用父类构造方法**，不然编译报错。
* 规范：不要让子类随意访问、修改父类的方法，如：父类中辅助其他的工具方法引用Private修饰；不希望**被重写的且需要被外部类引用的**可以用final public修饰。不要在父类构造器中使用将被子类重写的方法。

### 多态：
1. 引用变量有两种类型，一个是编译时类型，另一个是运行时类型，前者是指声明定义的，后者是实际指向的。
2. 多态：把子类对象赋给父类引用，**使相同类型的变量、调用同一个方法时呈现出多种不同的行为特征**。
3. 注意：1.**对象的实例变量不具备多态性**，调用时，还是使用父类的实例变量，多态的是方法；2.**编译阶段只能使用编译时类型所拥有的方法**，即编写时，只能调用父类的方法名。
4. 为什么要注意**编译时类型**：因为编译时类型决定程序是否会编译报错；

### 引用变量的强制类型转换
1. 只能在有继承关系的两个类型之间进行转换，不然会在**程序编译时**报错；
2. 还有一种**程序运行时**会报错（ClassCastExceptioin）的情况，如：
```
Object obj = new Integer(5);
String str = (String) obj;
```
上述情况会报错，因为转换的类型与**变量的运行时类型**不是继承关系！**所以引用类型转换时要考虑变量的编译时类型和运行时类型!**

#### 关键字instanceof
1. 为了防止引用类型转换**在程序运行时**出错，可以先用`instanceof`进行判断。
2. 格式：引用变量 instanceof 类名；
3. 判断前者是否是后者的**实例**。
4. 会出现`编译报错异常`的情况：需要判断的变量的`编译时类型`与后面的类名不是同类或子类关系
    ```
    //编译报错，string和math没有继承关系
    String s = "hello";
    s instanceof Math;

    //正确的情况
    Object d = "hello";
    //虽然变量d的运行时类型为string，但是编译时类型object是math的父类。
    d instanceof Math;
    ```
5. 综上所述：`instanceof`使用时，**是否报错**取决于前后`编译时类型是否有继承关系`；而**运算结果的对错**取决于`实际运行时类型`；

## 类的类型
#### 不可变类
1. 定义：创建该类实例后，该类实例变量不可改变；
2. 规则：
    * 使用final private来修饰变量；
    * 提供带参数的构造器；
    * 只提供getter方法不提供setter方法；
    * 必要时重写hashcode()和equals()方法；
3. 注意：不可变类的成员变量为引用类型时，也应该让其引用类型为不可变类；

#### 抽象类
1. 在讲抽象类之前必须要介绍抽象方法，因为抽象类是为了解决父类引用调用子类具体实例方法实现而设计的，抽象方法就是用来代表某些子类方法，提供给程序编写时使用。
    * 理解"供编程时使用这句话含义"的第一点：认识到编译时与运行时两种状态下代码执行是不同；第二点：使用多态特性，实际上是使用父类引用，而**父类引用在编译时只能使用父类中定义的成员**。如：
    ```
    class A{
        public test(){
            ....
        }
    }
    class B extends A{
        public test2(){
            ....
        }
    }
    public class C{
        public static void main(String[] args){
            //a变量现在是父类A类引用，指向B类实例
            A a = new B();
            //能调用A类定义的方法
            a.test();
            //不能调用B类定义的方法，下面代码编译就会报错
            //a.test2();
        }
    }
    ```
2. 使用abstract修饰的方法，称为抽象方法，抽象方法没有方法体（即没有具体实现），只是用来定义；使用abstract修饰的类就是抽象类；抽象方法与抽象类的关系：**拥有抽象方法的类一定要定义成抽象类**；
3. 抽象类的特性：
    * 不能被实例化，但可以有构造方法；
    * 抽象类可以有：**成员变量、方法（普通方法或者抽象方法）、构造器、初始化块、内部类**5种成分；
    * 抽象类的子类可以是普通类，也可以是抽象类；如果是普通类则必须实现所有的抽象方法；
4. 由于抽象方法必须要重写才能有用，所以：final和private两个修饰词都不能与abstract一起用；
5. **static用来修饰方法的话，说明是类方法，同样不能与abstract同用**，但可以用来修饰`内部类`（定义一个抽象静态内部类，然后用匿名内部类创建实例）；

#### 接口
1. 使用interface修饰的类；实际上是一个特殊的抽象类，同样不能被实例化。
2. 特性：
    * **不能包含普通方法，全是抽象方法**，java8之后可以拥有默认方法；
    * 可以包含：**静态常量、抽象实例方法、类方法、默认方法、内部类**（注意可以有类方法）
    * 一个类可以实现多个接口；
    * 接口的成员只能使用public修饰，且默认是public；
    * **接口的常量要加static final修饰**；
    * 接口中的内部类、内部接口、内部枚举都是使用Public static修饰；
3. 使用implements关键字去定义一个类要实现一个接口；
4. 可以使用接口引用指向实现该接口的子类实例；

#### 抽象类和接口：
##### 相同：
1. 都不能被实例化；
2. 继承抽象类的类和实现接口的类，都必须实现其所有的抽象方法；

##### 不同：
1. 一个类只能继承一个抽象类，但可以实现多个接口；
2. 抽象类比接口多了**两种成员，构造器以及初始化块**；并且没有成员**变量**和普通方法。（**接口的成员是常量，而不是变量**）
3. 接口的所有方法都只能是抽象方法，用public abstract修饰，可以有静态方法；但抽象类还可以使用普通方法；
4. 接口的变量只能使用public static final修饰；抽象类可以使用普通变量。

#### 引用类型
**引用变量**可分为四种引用类型：
1. 强引用：
    一般的引用都是强引用，只要对象有强引用，对象就不会被垃圾回收机制（GC）回收；
2. 软引用：（通过SoftReference类实现）
    如果对象**只有软引用指向它**，那会在内存不足时，系统会自动回收这些对象，常用于内存敏感的程序中。
3. 弱引用（通过WeakReference类实现）
    如果对象**只有弱引用**，则会在**下一次GC**时，被回收；（不会被立即回收）
4. 虚引用（通过PhantomReference类实现）
    如果对象**只有虚引用**，则会立即被回收，虚引用用来跟踪垃圾回收状态，必须和引用队列联合使用。
    引用队列的概念：
    * 一般情况下，一个对象被标记为垃圾（不代表被回收）后，会加入到引用队列；
    * 虚引用只有在其指向对象被回收后加入引用队列
每一个引用类都包含一个get()方法，来获取他们所引用的对象。

