# java：面向对象编程语言——java基础总结（3）

# 面向对象与面向过程的区别？
### 面向过程：
1. 又名结构化设计，按**功能**分析系统需求；遵循**自顶向下、模块化设计**等原则；
2. 把系统按功能细分，每个功能要完成一定的数据处理，其设计的每个功能都负责对数据进行一次处理，形成数据流；
3. **最小程序单元为函数**；
4. 局限性：1.设计不够直观；和人的习惯思维不一样。2.适应性差，可扩展性不强；当需要改变时，需要自顶向下的修改模块结构。

### 面向对象:   
1. 面向对象的编程是一组对象互相配合通过沟通完成特定功能。 
2. 基本思想：使用类、对象、继承、封装、消息等基本概念进行设计；以现实世界中的事物（即对象）为中心进行思考；
3. 系统由类组成，类抽象了客观事物的本质特点；事物的状态为类的属性（property，成员变量），事物的行为为类的方法；
4. **最小的程序单元为类**；
5. 基本特征有：**封装、继承和多态**；
    >* 封装：隐藏对象的实现细节，通过**公用方法**暴露其功能；
    >* 继承：子类直接获得父类的属性和方法；提高了内聚性，降低了对象之间的耦合性。
    >* 多态：父类引用指向子类对象，运行时表现子类的行为。
6. 对象拥有：标识唯一性、分类型、多态性、封装性、模块独立性好的特点；
7. **消息**是指对象之间相互合作，实例于实例之间通信的机制；
    >**判断一门语言是否面向对象，通常看是否使用继承和多态加以判断**；

### 总结答案：
1. 出发点不同；面向过程是根据功能对系统需求进行结构化分析与设计，强调把解决问题的过程抽象化为模块，以过程为中心处理问题；而面向对象是以现实世界的事物（即对象）为中心，把客观事物抽象为类的处理问题；
2. 面向过程的最小程序单元为函数，系统由函数组成，自顶向下的进行模块化设计，通过函数对数据进行处理的过程来实现问题解决的过程；面向对象的最小程序单元为类，根据业务对事物的状态和行为的要求，定义类的属性和方法；创建对象，描述事物在解决问题步骤中的行为去实现解决问题的过程。
3. 面向过程的优点在于性能比面向对象高，因为不需要实例化，缺点是扩展性差、设计不直观与人的习惯思维不相同；面向对象的优点在于，由于具有继承、多态和封装的特性，使系统扩展性高、容易维护和低耦合，缺点在于性能较低。

## 类
* java是面向对象的编程，而其中核心就是围绕类来设计代码，所以我们下面来介绍类；
### 首先我们来介绍一下组成类的元素
#### 一、构造器（构造方法）
1. 写法上就是**与类名同名的一类方法**；定义后，可以通过调用这类方法创建类的实例；
    ```
    public class Test{
        //构造器
        Test(){}
    }
    ```
2. java默认提供一个无参数的构造方法，且调用时赋予成员变量默认值；如果**自定义一个构造器则系统不再提供这个无参的构造器**；
3. **构造器不完全负责对象得创建，但这是获取创建对象的途径**，因为在调用构造器前系统会自动先分配空间，初始化对象，然后再执行构造器代码并**将类的实例返回给调用者**；
4. 构造器之间可通过this关键词（后面介绍）相互调用，但是调用时**必须写在代码的第一行**；
```
public class Test{
    //构造器A
    Test(int a){}
    //构造器B，调用A    
    Test(int a,int b){
        this(a);
    }
}
```
5. 调用构造方法，使用new关键词调用,即获取一个类的实例;
```
User user = new User();
```
#### 二、初始化块
1. 有执行顺序，先定义的先执行；比构造器先隐式执行；
2. 定义形式：[修饰符]{...代码块}
3. 由于没有标识，则初始化块不能被调用，所以都是`在构造器隐式执行`；
4. 实际上初始化块是对构造器的补充，`编译时`系统会将其放到构造器中，**所以如果有段统一使用的初始化代码不需要参数，就应该写成初始化块**；

#### 三、成员变量
1. 主要分为静态成员变量和实例变量；在讲区别前必须要先介绍类对象和类的实例的区别；
2. 首先：每个类在java程序运行调用中，在被第一次调用时就会在内存中加载一个类对象（实际上是一个Class类的实例，后面讲解类的加载的时候会再详细说明），然后再由这个类对象生成一个我们需要的实例到内存中（用new关键词，即调用构造方法）。**为什么内存中要有同一个类定义的两种对象呢？**
    >* 举个简单例子：比如上帝编写好了人这个生物的模板文本(**对应我们定义的类**)，例如规定了人要吃饭(**对应方法**)，人有身高体重这些数值(**对应成员变量**)等等都写成了文本，然后按这个本文模板生成我们熟悉的DNA对应(**对应类对象**)，交给大自然(**对应java虚拟机**)生成人这个生物，根据具体数值的不同，生成各种各样的人(**对应类实例**)，目的是让各种各样的人根据自己的能力(**具体数值的差异导致能力的不同**)去完成各种工作；
    >* 上面的例子用一句话对应回我们的程序，我们需要根据类对象这个模板，在不同的功能模块中，通过设置不同的数值生成不同的类的实例去完成我们不同的功能。所以我们内存中会有两种同一个类的对象；而且**类对象中的变量是可以被所有类的实例使用（因为是模板嘛）**
3. 回到变量中，静态变量是**使用static关键词修饰**，并存放在类对象中的，在类加载时被初始化，**可以被任何一个类的实例修改的**；而实例变量是类的实例独有的，在创建实例时才被初始化；
    ```
    class User{
        //静态变量
        static int a;
        //实例变量
        int b;
    }
    ```
4. 怎么去使用成员变量进行运算呢？一般在方法中使用，具体在方法这个模块说吧；
5. 成员变量初始化(即变量赋值)时，**整型和浮点型数据都为0；布尔为false；引用为Null；字符为空字符**。

#### 四、方法
1. 方法也分为静态与实例，同变量一致；方法的定义格式：
    ```
    /*
    <修饰符> <方法返回值类型> <方法名>(参数列表){
        ...(方法体即处理逻辑代码)
        return;
    }
    */
    //void是特殊返回值类型，代表方法没有返回值
    public static void main(String args[]){
        .......
    }
    ```
2. java方法参数的传递机制：**值传递**；即将实际参数值的副本传入到方法内，参数本身不变。
3. 定义一个形参个数可变的方法：定义方法时，在最后一个形参类型后增加三个点（...），则表明该形参可接受多个参数中，被当成数组传入。如：
    ```
    public void test(int a,String... books){}
    ```
    >上面声明了String类型的参数可以为多个。实际上是当做数组所以**可以换成String[] books**，但是传入的时候**后者必须定义一个数组传入，而前者不需要，直接传多个字符串参数即可**。
**每个方法只能有一个个数可变的形参且定义在参数列表最后**。
4. 方法的重载和重写
    * 方法的重载：
    >在**同一个类**里，方法名相同，参数列表不同，就称为方法的重载；
    >不能用**返回值类型**来判断区分重载的方法，如果有方法名相同，返回值不同的情况，编译时会报方法名重复的错；
    >java识别方法的方法是：1.看方法名；2.看参数列表。
    * 方法的重写：
    >在子类中，包含与父类相同名的方法称为重写；
    >遵循**两同两小一大**，两同指：方法名相同，**参数列表**相同；两小指：**返回值类型和抛出的异常**子类方法要比父类**小（子类）或者相同**；一大指：**访问权限**子类比父类大或者相同。
5. 方法中调用变量：
    * 对于同一个类中调用同一类的成员变量，直接写变量名；但最重要的规则是：**静态方法不能直接调用非静态的成员（包含方法与变量）**；
    * 方法中也可以定义方法变量，可以与成员变量同名；同名时选择方法变量，如果要使用成员变量则要用this关键词；
    * 对于不同类的成员变量，如果要调用**实例变量**，则要先创建一个类的实例即new,然后用<实例对象名>.<变量名>格式调用；对于**静态变量**，则使用<类名>.<变量名>这个格式调用；
6. 方法调用别的方法：
    * 同一个类中，直接写方法名与参数列表，即：<方法名>(参数列表)这个格式；但**静态方法不能直接调用非静态的成员（包含方法与变量）**；
    * 不在同一个类中，同样对于**实例方法**，先创建类实例，再用<实例对象名>.<方法名>格式调用；对于**静态方法**，则使用<类名>.<方法名>这个格式调用；
7. **方法只有执行时才占用内存**

#### 五、类中关键字
##### super和this
1. this指代类的`实例`本身；
2. super代指类的父类（看下面继承机制）的`实例`；
    >**都不可以与static共用**；this是调用自己类的实例变量和方法，super是调用父类的实例变量和方法，因为都要先找到调用的对象本身，所以不能与static通用，因为静态方法和变量是属于类而不是对象。

##### final
1. 修饰变量则必须在定义时或者初始化块或者构造器中赋值，后续不能改变，**系统不会对其进行隐式的初始化**；修饰方法则该方法不能被重写；
2. 修饰一个引用变量时，变量指向的地址不能变，但对应变量可以做修改；
3. 宏变量：在编译的时候就可以确定下值的变量就会直接在编译时转换成对应值；情况：直接赋值、由简单算术表达式或者字符连接；**特殊：字符的常量池**
    ```
    main(){
        String s1 = "疯狂java";
        String s2 = "疯狂"+"java"；
        String s3 = "疯狂"；
        String s4 = "java";
        String s5 = s3+s4;
        //s2是直接两个字符连接
        System.out.prinln(s1 == s2);//true
        //s5是两个变量连接
        //如果想让s1==s5为true,则将s3和s4用final修饰
        System.out.prinln(s1 == s5);//false
    }
    ```

#### 六、访问控制(修饰符，修饰**类、方法、成员变量**)：
1. private、default、protected、public
2. private:当前类访问对象权限，用来修饰类的成员变量和方法；外部类只能用setter和getter方法访问被修饰的变量；
3. default：包访问权限，默认的权限修饰，只有同一个包下的类才能访问被修饰的类，方法，变量；
4. protected：子类访问权限，只有子类才能访问；
5. public：公共访问，所有外部类都能访问；
6. 原则：
    1. 变量尽量用private修饰成私有，辅助类中方法的工具方法也用private;
    2. 父类中需要重写的方法用protect;

总结几点容易被忽视的：
1. 成员变量初始化时，**整型和浮点型数据都为0；布尔为false；引用为Null；字符为空字符**。
2. **方法只有执行时才占用内存**
3. 构造方法与类**同名**，不用写返回值类型；每个类默认有一个无参数的构造方法，但是如果自定义了构造方法就不会有默认
4. 构造方法不需要命名返回值，因为返回类型总是当前类，不需要return，因为返回值是隐式的。
5. 创建对象的根本途径是**调用构造器**；
6. 如果希望创建的对象被回收则将其引用赋值为Null；
7. 静态成员不能直接访问非静态成员；
8. java类中**方法有默认主调**（主调：调用方法和变量的对象）；普通成员方法主调为**this**，而**静态方法的主调为类**，所以静态方法中不能调用非静态成员，**但非静态可以调用静态成员**。（**这句话解释了所有类中调用成员的情况**）
9. java允许对象来调用static修饰的成员变量。